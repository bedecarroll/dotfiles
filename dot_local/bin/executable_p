#!/usr/bin/env python3
"""Generate pastable file from TMUX/WezTerm output."""

# Disable and lower linting because we target py38
# ruff: noqa: PGH004
# ruff: noqa
# pyright: basic

import argparse
import os
import re
import shlex
import subprocess
import sys
import time
from enum import Enum
from pathlib import Path
from tempfile import TemporaryDirectory


class FinishCommands(Enum):
    """Supported commands to send output to."""

    GIST = "gist"
    TEE = "tee"
    STDOUT = "stdout"


PROMPT_RE = re.compile(r"^\[\d+\]\[\d+\].*\s\S+@\S+\$\s")
MAX_SCROLLBACK = -10_000_000


def _gen_finishing_command(what_command):
    """Shell command(s) that handle the output."""
    if what_command == FinishCommands.GIST:
        return [
            "gh",
            "gist",
            "create",
        ], None
    elif what_command == FinishCommands.TEE:
        dt = time.strftime("%Y%m%d-%H%M%S")
        tee_path = str(Path("~/paste_{}.txt".format(dt)).expanduser())
        return [
            "tee",
            str(tee_path),
        ], str(tee_path)
    return None, None


def get_wezterm_pane_history():
    """Get wezterm buffer and split it into lines."""
    try:
        pane_scrollback = subprocess.run(
            [
                "/usr/bin/env",
                "wezterm",
                "cli",
                "get-text",
                "--start-line",
                str(MAX_SCROLLBACK),
            ],
            capture_output=True,
            check=True,
            encoding="utf-8",
        )
        return pane_scrollback.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print("Error running wezterm: {}".format(e), file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("wezterm not found. Install wezterm or use tmux.", file=sys.stderr)
        sys.exit(2)


def get_tmux_pane_history():
    """Get tmux buffer and split it into lines."""
    try:
        pane_scrollback = subprocess.run(
            [
                "/usr/bin/env",
                "tmux",
                "capture-pane",
                "-p",  # output to stdout
                "-S",
                "-",  # means -S will go to the start of the pane history
            ],
            capture_output=True,
            check=True,
            encoding="utf-8",
        )
        return pane_scrollback.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print("Error running tmux: {}".format(e), file=sys.stderr)
        sys.exit(3)
    except FileNotFoundError:
        print("tmux not found. Install tmux or use wezterm.", file=sys.stderr)
        sys.exit(4)


def split_output(scrollback):
    """Take a pane history and split based on the prompt regex."""
    # Not a defaultdict so that we can get duplicate commands
    command_and_output = []
    output = []
    for line in scrollback:
        if PROMPT_RE.match(line) and output:
            # NOTE: Skip when there is no output
            if len(output) > 1:
                command_and_output.append(output)
            output = []
        output.append(line.rstrip(" \t"))

    if not command_and_output:
        print("No command prompts found. Check regex.", file=sys.stderr)
        sys.exit(10)
    return command_and_output


def get_wanted_output(command_and_output):
    """Use FZF to find out which outputs the user wants."""
    fuzzy_search_lines = []
    with TemporaryDirectory() as td:
        # Index is the filename and what number to select
        for index, output in enumerate(command_and_output):
            # This is the line with the command you ran, e.g. $ ls
            prompt_command = output[0]
            # Generate what FZF is going to allow you to select from
            fuzzy_search_lines.append("{}\t{}".format(index, prompt_command))
            # Generate the temp files
            with open(os.path.join(td, str(index)), "w") as cf:
                cf.write("\n".join(output))

        try:
            selected_output = subprocess.run(
                [
                    "/usr/bin/env",
                    "fzf",
                    "--tac",  # reverse order so it matches history
                    "--multi",  # allow multi select
                    "+s",  # disable sorting
                    "--preview=cat {}/{{1}}".format(shlex.quote(td)),
                ],
                # Send the commands and filenames to fuzzy find on
                input="\n".join(fuzzy_search_lines),
                check=False,  # Failure means we wanted nothing
                capture_output=True,
                encoding="utf-8",
            )
        except FileNotFoundError:
            print("fzf not found. Install fzf to use this tool.", file=sys.stderr)
            sys.exit(5)

        # We wanted nothing, exit
        if selected_output.returncode != 0:
            sys.exit(0)

        filtered_command_and_output = []
        for line in selected_output.stdout.splitlines():
            index = int(line.split("\t")[0])
            filtered_command_and_output.append(command_and_output[index])
        return filtered_command_and_output


def generate_output(filtered_command_and_output, destination):
    """Take the output we want and do 'something' with it."""
    output_strings = []
    for selected_output in filtered_command_and_output:
        command = selected_output[0]
        if destination != FinishCommands.STDOUT:
            print('Pasting output of "{}"'.format(command), file=sys.stderr)
        output_strings.append("\n".join(selected_output))
    final_output = "\n".join(output_strings)

    finishing_command, tee_path = _gen_finishing_command(destination)
    if finishing_command is None:
        print(final_output)
        return
    try:
        subprocess.run(
            finishing_command,
            input=final_output,
            check=False,
            encoding="utf-8",
            stdout=subprocess.DEVNULL,
        )
    except FileNotFoundError as e:
        print("Required command not found: {}".format(e), file=sys.stderr)
        sys.exit(6)

    if destination == FinishCommands.GIST:
        try:
            gist_url = subprocess.run(
                ["gh", "api", "gists", "-q", ".[0] | .html_url"],
                capture_output=True,
                check=True,
                encoding="utf-8",
            )
            print(gist_url.stdout.strip())
        except subprocess.CalledProcessError as e:
            print("Error getting gist URL: {}".format(e), file=sys.stderr)
    elif destination == FinishCommands.TEE and tee_path:
        print(tee_path)


def _parse_destination(dest_str):
    """Parse destination string to FinishCommands enum."""
    dest = dest_str.lower()
    if dest == "gist":
        return FinishCommands.GIST
    elif dest == "tee":
        return FinishCommands.TEE
    elif dest == "stdout":
        return FinishCommands.STDOUT
    else:
        raise argparse.ArgumentTypeError(
            "destination must be 'gist', 'tee', or 'stdout'"
        )


def main():
    """Entrypoint."""
    possible_destinations = ", ".join(x.value for x in FinishCommands)
    parser = argparse.ArgumentParser(description="Get selected text from scrollback.")
    parser.add_argument(
        "output_destination",
        type=_parse_destination,
        nargs="?",
        help="Possible destinations: {}. Default is tee, a file in your homedir.".format(
            possible_destinations
        ),
    )
    args = parser.parse_args()

    # Determine destination: CLI arg takes precedence over env var
    destination = args.output_destination
    if destination is None:
        env_dest = os.environ.get("PASTE_DEST", "tee").lower()
        try:
            destination = _parse_destination(env_dest)
        except argparse.ArgumentTypeError:
            print(
                "Invalid PASTE_DEST ({}); defaulting to 'tee'.".format(env_dest),
                file=sys.stderr,
            )
            destination = FinishCommands.TEE

    if "TMUX" in os.environ:
        scrollback = get_tmux_pane_history()
    else:
        scrollback = get_wezterm_pane_history()
    split_scrollback = split_output(scrollback)
    filtered_output = get_wanted_output(split_scrollback)
    generate_output(filtered_output, destination)


if __name__ == "__main__":
    main()
