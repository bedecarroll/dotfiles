#!/usr/bin/env python3
"""Generate pastable file from TMUX output."""

# Prints are normal and we aren't sending user input to .run()
# ruff: noqa: T201,S603

import argparse
import os
import re
import subprocess
import sys
import time
from enum import Enum
from pathlib import Path
from tempfile import TemporaryDirectory


class FinishCommands(Enum):
    """Supported commands to send output to."""

    GIST = "gist"
    TEE = "tee"


FINISH_COMMAND = FinishCommands.TEE
PROMPT_RE = re.compile(r"^\[\d+\]\[\d+\].*\s\S+@\S+\$\s")
MAX_SCROLLBACK = -10_000_000


def _gen_finishing_command(what_command):
    """Shell command(s) that handle the output."""
    if what_command == FinishCommands.GIST:
        return [
            "gh",
            "gist",
            "create",
        ]
    elif what_command == FinishCommands.TEE:
        dt = time.strftime("%Y%m%d-%H%M%S")
        return [
            "tee",
            str(Path("~/paste_{}.txt".format(dt)).expanduser()),
        ]


def get_wezterm_pane_history():
    """Get wezterm buffer and split it into lines."""
    pane_scrollback = subprocess.run(
        [
            "/usr/bin/env",
            "wezterm",
            "cli",
            "get-text",
            "--start-line",
            str(MAX_SCROLLBACK),
        ],
        stdout=subprocess.PIPE,
        check=True,
        encoding="utf-8",
    )

    return pane_scrollback.stdout.splitlines()


def get_tmux_pane_history():
    """Get tmux buffer and split it into lines."""
    pane_scrollback = subprocess.run(
        [
            "/usr/bin/env",
            "tmux",
            "capture-pane",
            "-p",  # output to stdout
            "-S",
            "-",  # means -S will go to the start of the pane history
        ],
        stdout=subprocess.PIPE,
        check=True,
        encoding="utf-8",
    )

    return pane_scrollback.stdout.splitlines()


def split_tmux_history(scrollback):
    """Take a pane history and split based on the prompt regex."""
    # Not a defaultdict so that we can get duplicate commands
    command_and_ouput = []
    output = []
    for line in scrollback:
        if PROMPT_RE.match(line) and output:
            # NOTE: Skip when there is no output
            if len(output) > 1:
                command_and_ouput.append(output)
            output = []
        output.append(line)

    if not command_and_ouput:
        print("No command prompts found. Check regex.", file=sys.stderr)
        sys.exit(50)
    return command_and_ouput


def get_wanted_output(command_and_ouput):
    """Use FZF to find out which outputs the user wants."""
    fuzzy_search_lines = []
    with TemporaryDirectory() as td:
        # Index is the filename and what number to select
        for index, output in enumerate(command_and_ouput):
            # This is the line with the command you ran, e.g. $ ls
            prompt_command = output[0]
            # Generate what FZF is going to allow you to select from
            fuzzy_search_lines.append("{}\t{}".format(index, prompt_command))
            # Generate the temp files
            with open(os.path.join(td, str(index)), "w") as cf:
                cf.write("\n".join(output))

        selected_output = subprocess.run(
            [
                "/usr/bin/env",
                "fzf",
                "--tac",  # reverse order so it matches history
                "--multi",  # allow multi select
                "+s",  # disable sorting
                "--preview=cat {}/{{1}}".format(td),
            ],
            # Send the commands and filenames to fuzzy find on
            input="\n".join(fuzzy_search_lines),
            check=False,  # Failure means we wanted nothing
            capture_output=True,
            encoding="utf-8",
        )
        # We wanted nothing, exit
        if selected_output.returncode != 0:
            sys.exit(0)

        filtered_command_and_output = []
        for line in selected_output.stdout.splitlines():
            index = int(line.split("\t")[0])
            filtered_command_and_output.append(command_and_ouput[index])
        return filtered_command_and_output


def generate_output(filtered_command_and_output, destination):
    """Take the output we want and do 'something' with it."""
    output_strings = []
    for selected_output in filtered_command_and_output:
        command = selected_output[0]
        print('Pasting output of "{}"'.format(command))
        output_strings.append("\n".join(selected_output))
    final_output = "\n".join(output_strings)
    subprocess.run(
        _gen_finishing_command(destination),
        input=final_output,
        check=False,
        encoding="utf-8",
        stdout=subprocess.DEVNULL,
    )


def _parse_destination(dest_str):
    """Parse destination string to FinishCommands enum."""
    if dest_str == "gist":
        return FinishCommands.GIST
    elif dest_str == "tee":
        return FinishCommands.TEE
    else:
        raise argparse.ArgumentTypeError("destination must be 'gist' or 'tee'")


def main():
    """Entrypoint."""
    possible_destinations = ", ".join(x.value for x in FinishCommands)
    parser = argparse.ArgumentParser(description="Get selected text from scrollback.")
    parser.add_argument(
        "output_destination",
        type=_parse_destination,
        nargs="?",
        help="Possible destinations: {}. Default is tee, a file in your homedir.".format(possible_destinations),
    )
    args = parser.parse_args()

    # Determine destination: CLI arg takes precedence over env var
    destination = args.output_destination
    if destination is None:
        env_dest = os.environ.get("PASTE_DEST", "tee").lower()
        destination = _parse_destination(env_dest)

    if "TMUX" in os.environ:
        scrollback = get_tmux_pane_history()
    else:
        scrollback = get_wezterm_pane_history()
    split_scrollback = split_tmux_history(scrollback)
    filtered_output = get_wanted_output(split_scrollback)
    generate_output(filtered_output, destination)


if __name__ == "__main__":
    main()
